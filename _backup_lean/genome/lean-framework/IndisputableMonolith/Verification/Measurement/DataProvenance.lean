import Mathlib

/-!
# Data Provenance Infrastructure

This module defines the **quarantine infrastructure** for empirical data.
All measurement results, calibration constants, and mined datasets must
be wrapped in provenance records.

## Purpose

The certified surface (theorem-level claims) must not depend on raw
empirical data. This module provides:

1. **DataProvenance**: Record tracking data source, hash, generator
2. **MeasurementResult**: Wrapper for empirical values with provenance
3. **HypothesisFromData**: Bridge between data and certified claims

## Quarantine Rules

- Modules in `Verification/Measurement/*` are **quarantined**
- The certified surface may NOT import quarantined modules
- Test suites (in `Verification/Preregistered/*`) may import both

-/

namespace IndisputableMonolith
namespace Verification
namespace Measurement

/-! ## Provenance Records -/

/-- Source type for empirical data. -/
inductive DataSource
  | manual         -- Hand-entered by researcher
  | computation    -- Generated by computation
  | external       -- From external database/API
  | mining         -- Extracted from datasets
  | calibration    -- Tuning/optimization result
  deriving DecidableEq, Repr

/-- Provenance record for empirical data.
    Every piece of data in the quarantine zone must have this. -/
structure DataProvenance where
  /-- Human-readable description -/
  description : String
  /-- Source type -/
  source : DataSource
  /-- SHA-256 hash of the data artifact (hex string) -/
  dataHash : String
  /-- Path to generator script (if computation/mining) -/
  generatorScript : Option String
  /-- Timestamp of data generation (ISO 8601) -/
  timestamp : String
  /-- Version identifier -/
  version : String
  /-- Additional metadata (key-value pairs) -/
  metadata : List (String × String)
  deriving Repr

/-- Create a provenance record for manual data. -/
def DataProvenance.manual (desc : String) (timestamp : String) : DataProvenance :=
  { description := desc
  , source := .manual
  , dataHash := ""  -- No hash for manual entry
  , generatorScript := none
  , timestamp := timestamp
  , version := "1.0"
  , metadata := []
  }

/-- Create a provenance record for computed data. -/
def DataProvenance.computed (desc : String) (hash : String)
    (script : String) (timestamp : String) : DataProvenance :=
  { description := desc
  , source := .computation
  , dataHash := hash
  , generatorScript := some script
  , timestamp := timestamp
  , version := "1.0"
  , metadata := []
  }

/-- Create a provenance record for calibration. -/
def DataProvenance.calibrated (desc : String) (timestamp : String)
    (method : String) : DataProvenance :=
  { description := desc
  , source := .calibration
  , dataHash := ""
  , generatorScript := none
  , timestamp := timestamp
  , version := "1.0"
  , metadata := [("method", method)]
  }

/-! ## Measurement Results -/

/-- A measurement result with provenance tracking. -/
structure MeasurementResult (α : Type*) where
  /-- The measured value -/
  value : α
  /-- Uncertainty/error bound (if applicable) -/
  uncertainty : Option ℝ
  /-- Provenance record -/
  provenance : DataProvenance

/-- Extract just the value, discarding provenance. -/
def MeasurementResult.unwrap {α : Type*} (m : MeasurementResult α) : α := m.value

/-- Map over a measurement result, preserving provenance. -/
def MeasurementResult.map {α β : Type*} (f : α → β)
    (m : MeasurementResult α) : MeasurementResult β :=
  { value := f m.value
  , uncertainty := m.uncertainty
  , provenance := m.provenance
  }

/-! ## Hypothesis Bridge -/

/-- Status of a hypothesis derived from data. -/
inductive HypothesisStatus
  | unverified    -- Data exists but not validated
  | validated     -- Data validated by independent check
  | preregistered -- Used in preregistered test suite
  | deprecated    -- Superseded by newer data
  deriving DecidableEq, Repr

/-- A hypothesis derived from empirical data.
    This is the bridge between quarantined data and certified claims. -/
structure DataHypothesis (α : Type*) where
  /-- Name of the hypothesis -/
  name : String
  /-- The claimed value -/
  claim : α
  /-- Underlying measurement -/
  measurement : MeasurementResult α
  /-- Current status -/
  status : HypothesisStatus
  /-- Falsification condition (what would disprove this) -/
  falsifier : String
  /-- Removal plan (how to make this a theorem) -/
  removalPlan : String

/-- Create a hypothesis from a measurement. -/
def DataHypothesis.fromMeasurement {α : Type*}
    (name : String) (m : MeasurementResult α)
    (falsifier : String) (plan : String) : DataHypothesis α :=
  { name := name
  , claim := m.value
  , measurement := m
  , status := .unverified
  , falsifier := falsifier
  , removalPlan := plan
  }

/-! ## Calibration Constants (Quarantined) -/

/-- Classification threshold for the meaning compiler.
    This is a **calibration constant**, not a derived value. -/
def classifyThreshold_raw : MeasurementResult ℝ :=
  { value := 0.9
  , uncertainty := some 0.05
  , provenance := DataProvenance.calibrated
      "Classification threshold for exact token match"
      "2026-01-06"
      "Manual tuning on canonical bases"
  }

/-- Stability threshold for perturbation bounds.
    Derived from overlap perturbation analysis. -/
def stabilityThreshold_raw : MeasurementResult ℝ :=
  { value := 0.01
  , uncertainty := some 0.005
  , provenance := DataProvenance.computed
      "Stability threshold from Cauchy-Schwarz bound"
      ""  -- No hash yet
      "planning/MEANING_COMPILER_ASSUMPTION_LEDGER.md"
      "2026-01-06"
  }

/-- Net constant for CPM coercivity. -/
def C_net_raw : MeasurementResult ℝ :=
  { value := 1.0
  , uncertainty := none
  , provenance := DataProvenance.calibrated
      "Optimized for intrinsic neutrality preservation"
      "2026-01-06"
      "Coercivity optimization"
  }

/-- Projection constant for CPM. -/
def C_proj_raw : MeasurementResult ℝ :=
  { value := 2.0
  , uncertainty := none
  , provenance := DataProvenance.manual
      "Rank-one Hermitian bound"
      "2026-01-06"
  }

/-- Energy control constant for CPM. -/
def C_eng_raw : MeasurementResult ℝ :=
  { value := 2.5
  , uncertainty := some 0.2
  , provenance := DataProvenance.calibrated
      "Empirical from diagnostic runs"
      "2026-01-06"
      "Energy diagnostic analysis"
  }

/-! ## Hypotheses from Calibration -/

/-- Hypothesis: classification threshold 0.9 is optimal. -/
def classifyThreshold_hypothesis : DataHypothesis ℝ :=
  DataHypothesis.fromMeasurement
    "classifyThreshold"
    classifyThreshold_raw
    "Different threshold achieves better accuracy"
    "Derive from stability analysis + information theory"

/-- Hypothesis: stability threshold 0.01 is sufficient. -/
def stabilityThreshold_hypothesis : DataHypothesis ℝ :=
  DataHypothesis.fromMeasurement
    "stabilityThreshold"
    stabilityThreshold_raw
    "Perturbation changes classification within threshold"
    "Prove tight bound from overlap_perturbation_bound"

/-! ## Provenance Validation -/

/-- Check if provenance has all required fields. -/
def DataProvenance.isComplete (p : DataProvenance) : Bool :=
  p.description.length > 0 &&
  p.timestamp.length > 0 &&
  p.version.length > 0 &&
  (p.source ≠ .computation || p.generatorScript.isSome) &&
  (p.source ≠ .computation || p.dataHash.length > 0)

/-- Check if a hypothesis is ready for preregistration. -/
def DataHypothesis.isPreregisterable {α : Type*} (h : DataHypothesis α) : Bool :=
  h.measurement.provenance.isComplete &&
  h.falsifier.length > 0 &&
  h.removalPlan.length > 0

/-! ## Summary Report -/

/-- Convert DataSource to string. -/
def DataSource.toString : DataSource → String
  | .manual => "manual"
  | .computation => "computation"
  | .external => "external"
  | .mining => "mining"
  | .calibration => "calibration"

/-- List all calibration constants with their provenance. -/
def calibrationSummary : List (String × String × String) :=
  [ ("classifyThreshold", "0.9", classifyThreshold_raw.provenance.source.toString)
  , ("stabilityThreshold", "0.01", stabilityThreshold_raw.provenance.source.toString)
  , ("C_net", "1.0", C_net_raw.provenance.source.toString)
  , ("C_proj", "2.0", C_proj_raw.provenance.source.toString)
  , ("C_eng", "2.5", C_eng_raw.provenance.source.toString)
  ]

-- #eval calibrationSummary  -- Disabled: ℝ not computable

end Measurement
end Verification
end IndisputableMonolith
