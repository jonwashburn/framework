import Mathlib

namespace IndisputableMonolith
namespace RecogSpec

noncomputable section

/-- Basic ledger carrier augmented with optional bookkeeping data so downstream
modules can project canonical states without introducing additional structure. -/
structure Ledger where
  Carrier : Type
  state : Option Carrier := none
  tick : Option (Carrier → ℕ) := none

/-- Bridge over a ledger. -/
structure Bridge (L : Ledger) : Type where
  dummy : Unit := ()

/-- Units equivalence relation over bridges. -/
structure UnitsEqv (L : Ledger) : Type where
  Rel   : Bridge L → Bridge L → Prop
  refl  : ∀ B, Rel B B
  symm  : ∀ {B₁ B₂}, Rel B₁ B₂ → Rel B₂ B₁
  trans : ∀ {B₁ B₂ B₃}, Rel B₁ B₂ → Rel B₂ B₃ → Rel B₁ B₃

/-- Dimensionless predictions extracted from a bridge. -/
structure DimlessPack (L : Ledger) (B : Bridge L) : Type where
  alpha            : ℝ
  massRatios       : List ℝ
  mixingAngles     : List ℝ
  g2Muon           : ℝ
  strongCPNeutral  : Prop
  eightTickMinimal : Prop
  bornRule         : Prop

/-- Absolute (SI) packaging for reference displays, distinct from dimensionless pack. -/
structure AbsolutePack (L : Ledger) (B : Bridge L) : Type where
  c_SI        : ℝ
  hbar_SI     : ℝ
  G_SI        : ℝ
  Lambda_SI   : ℝ
  masses_SI   : List ℝ
  energies_SI : List ℝ

/-- Subfield generated by `φ`. -/
def phiSubfield (φ : ℝ) : Subfield ℝ :=
  Subfield.closure ({φ} : Set ℝ)

/-- The value `x` is algebraic over the subfield generated by `φ` using field
operations. -/
def PhiClosed (φ x : ℝ) : Prop := x ∈ phiSubfield φ

namespace PhiClosed

variable {φ x y : ℝ}

@[simp] lemma mem : PhiClosed φ x ↔ x ∈ phiSubfield φ := Iff.rfl

lemma self (φ : ℝ) : PhiClosed φ φ := by
  change φ ∈ phiSubfield φ
  exact Subfield.subset_closure (by simp)

lemma of_rat (φ : ℝ) (q : ℚ) : PhiClosed φ (q : ℝ) := by
  change ((algebraMap ℚ ℝ) q) ∈ phiSubfield φ
  simpa using (phiSubfield φ).algebraMap_mem q

lemma zero (φ : ℝ) : PhiClosed φ (0 : ℝ) :=
  (phiSubfield φ).zero_mem

lemma one (φ : ℝ) : PhiClosed φ (1 : ℝ) :=
  (phiSubfield φ).one_mem

lemma add (hx : PhiClosed φ x) (hy : PhiClosed φ y) :
    PhiClosed φ (x + y) :=
  (phiSubfield φ).add_mem hx hy

lemma sub (hx : PhiClosed φ x) (hy : PhiClosed φ y) :
    PhiClosed φ (x - y) :=
  (phiSubfield φ).sub_mem hx hy

lemma neg (hx : PhiClosed φ x) : PhiClosed φ (-x) :=
  (phiSubfield φ).neg_mem hx

lemma mul (hx : PhiClosed φ x) (hy : PhiClosed φ y) :
    PhiClosed φ (x * y) :=
  (phiSubfield φ).mul_mem hx hy

lemma inv (hx : PhiClosed φ x) : PhiClosed φ x⁻¹ :=
  (phiSubfield φ).inv_mem hx

lemma div (hx : PhiClosed φ x) (hy : PhiClosed φ y) :
    PhiClosed φ (x / y) :=
  (phiSubfield φ).div_mem hx hy

lemma pow (hx : PhiClosed φ x) (n : ℕ) : PhiClosed φ (x ^ n) := by
  simpa using (phiSubfield φ).pow_mem hx n

lemma pow_self (φ : ℝ) (n : ℕ) : PhiClosed φ (φ ^ n) :=
  pow (self φ) n

lemma inv_self (φ : ℝ) : PhiClosed φ (φ⁻¹) :=
  inv (self φ)

lemma inv_pow_self (φ : ℝ) (n : ℕ) : PhiClosed φ ((φ ^ n)⁻¹) :=
  inv (pow_self φ n)

lemma of_nat (φ : ℝ) (n : ℕ) : PhiClosed φ (n : ℝ) := by
  simpa using of_rat φ n

lemma half (φ : ℝ) : PhiClosed φ (1 / (2 : ℝ)) := by
  have htwo : PhiClosed φ ((2 : ℚ) : ℝ) := of_rat φ 2
  simpa using inv htwo

end PhiClosed

/-- Universal φ-closed targets RS claims are forced to take. -/
structure UniversalDimless (φ : ℝ) : Type where
  alpha0        : ℝ
  massRatios0   : List ℝ
  mixingAngles0 : List ℝ
  g2Muon0       : ℝ
  strongCP0     : Prop
  eightTick0    : Prop
  born0         : Prop
  alpha0_isPhi        : PhiClosed φ alpha0
  massRatios0_isPhi   : ∀ r ∈ massRatios0, PhiClosed φ r
  mixingAngles0_isPhi : ∀ θ ∈ mixingAngles0, PhiClosed φ θ
  g2Muon0_isPhi       : PhiClosed φ g2Muon0

/-- "Bridge B matches universal U" (pure proposition). -/
def Matches (φ : ℝ) (L : Ledger) (B : Bridge L) (U : UniversalDimless φ) : Prop :=
  ∃ (P : DimlessPack L B),
    P.alpha = U.alpha0
      ∧ P.massRatios = U.massRatios0
      ∧ P.mixingAngles = U.mixingAngles0
      ∧ P.g2Muon = U.g2Muon0
      ∧ P.strongCPNeutral = U.strongCP0
      ∧ P.eightTickMinimal = U.eightTick0
      ∧ P.bornRule = U.born0

end

end RecogSpec
end IndisputableMonolith
